"""Benchmark: Dynamic Non-Stationary Noise (Party/TV/Music).

This benchmark tests the engine's ability to detect alarms in the presence of
rapidly changing background noise, simulating a "Cocktail Party" or "Action Movie" environment.

The noise is generated by summing multiple randomized "sources":
1. "Speech-like" Bursts: Band-passed noise that shifts frequency and amplitude rapidly.
2. "Music-like" Beats: Low-frequency impulses.
3. "Clatter": High-frequency transient spikes (dishes, keys).
"""

import logging
import os
import sys
import tempfile
from pathlib import Path

import numpy as np
from scipy.io import wavfile

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

from acoustic_alarm_engine.models import AlarmProfile, Range, Segment
from acoustic_alarm_engine.tester.display import Display
from acoustic_alarm_engine.tester.runner import TestRunner

# Setup logging
logging.basicConfig(level=logging.ERROR)


class DynamicAudioGenerator:
    def __init__(self, sample_rate: int = 44100):
        self.sample_rate = sample_rate

    def generate_speech_babble(self, duration: float, num_voices: int = 3) -> np.ndarray:
        """Simulate speech babble using modulated band-passed noise."""
        total_samples = int(self.sample_rate * duration)
        mix = np.zeros(total_samples)

        for _ in range(num_voices):
            # Each "voice" is a band of noise that shifts center freq every 200-500ms
            current_idx = 0
            while current_idx < total_samples:
                seg_dur = np.random.uniform(0.1, 0.5)
                seg_len = int(seg_dur * self.sample_rate)
                end_idx = min(current_idx + seg_len, total_samples)

                if end_idx <= current_idx:
                    break

                # Generate formant-like noise (narrow band)
                center_freq = np.random.uniform(300, 3500)  # Formant range
                width = np.random.uniform(100, 500)

                t = np.arange(end_idx - current_idx) / self.sample_rate
                # Carrier
                carrier = np.random.randn(len(t))
                # Modulator (sine wave at center freq)
                mod = np.sin(2 * np.pi * center_freq * t)

                # Simple AM modulation of noise creates a "voiced" sound feel
                segment = carrier * mod

                # Amplitude envelope (attack/decay)
                env = np.ones_like(segment)
                attack = int(0.05 * self.sample_rate)
                if len(env) > 2 * attack:
                    env[:attack] = np.linspace(0, 1, attack)
                    env[-attack:] = np.linspace(1, 0, attack)

                mix[current_idx:end_idx] += segment * env * np.random.uniform(0.3, 0.8)
                current_idx = end_idx

        return mix

    def generate_transients(self, duration: float, density: float = 1.0) -> np.ndarray:
        """Generate sudden high-freq clicks/claps (dishes, doors)."""
        total_samples = int(self.sample_rate * duration)
        audio = np.zeros(total_samples)

        num_events = int(duration * density)
        for _ in range(num_events):
            start = np.random.randint(0, total_samples - 1000)
            length = np.random.randint(500, 2000)  # Short click

            # High freq burst
            freq = np.random.uniform(2000, 8000)
            t = np.arange(length) / self.sample_rate
            burst = np.sin(2 * np.pi * freq * t) * np.exp(-100 * t)  # Exp decay

            end = min(start + length, total_samples)
            audio[start:end] += burst[: end - start] * np.random.uniform(0.5, 1.0)

        return audio

    def mix_dynamic_scene(
        self, duration: float, babble_lvl: float, clatter_lvl: float
    ) -> np.ndarray:
        babble = self.generate_speech_babble(duration) * babble_lvl
        clatter = self.generate_transients(duration, density=2.0) * clatter_lvl
        return babble + clatter

    def add_alarm(self, audio: np.ndarray, alarm_freq: float = 3000.0) -> np.ndarray:
        # Standard T3
        pattern = [(0.5, 0.5), (0.5, 0.5), (0.5, 1.5)]
        t = np.arange(len(audio)) / self.sample_rate

        current_t = 1.0
        while current_t < (len(audio) / self.sample_rate) - 1.0:
            for on, off in pattern:
                start = int(current_t * self.sample_rate)
                end = int((current_t + on) * self.sample_rate)
                if end >= len(audio):
                    break

                seg_t = t[start:end]
                # Alarm is 0.5 amplitude
                tone = np.sin(2 * np.pi * alarm_freq * seg_t) * 0.5
                audio[start:end] += tone

                current_t += on + off
        return audio


def run_benchmark():
    print("=" * 70)
    print("üöÄ DYNAMIC NOISE BENCHMARK (Party/TV Simulation)")
    print("=" * 70)

    gen = DynamicAudioGenerator()
    temp_dir = tempfile.mkdtemp()

    # Create Profile
    profile = AlarmProfile(
        name="Smoke Alarm",
        segments=[
            Segment(type="tone", frequency=Range(2900, 3100), duration=Range(0.4, 0.6)),
            Segment(type="silence", duration=Range(0.4, 0.6)),
            Segment(type="tone", frequency=Range(2900, 3100), duration=Range(0.4, 0.6)),
            Segment(type="silence", duration=Range(0.4, 0.6)),
            Segment(type="tone", frequency=Range(2900, 3100), duration=Range(0.4, 0.6)),
            Segment(type="silence", duration=Range(1.3, 1.7)),
        ],
    )

    from acoustic_alarm_engine.profiles import save_profiles_to_yaml

    profile_path = os.path.join(temp_dir, "profile.yaml")
    save_profiles_to_yaml([profile], profile_path)

    # Scenarios: "Babble Level" vs "Clatter Level"
    # Normalizing relative to Alarm (Amp 0.5)
    # 1.0 Babble means the speech peaks are roughly equal to the alarm
    scenarios = [
        ("Quiet Room", 0.05, 0.0),
        ("TV in Background", 0.3, 0.1),
        ("Loud Party", 0.8, 0.5),
        ("Chaos (Louder than Alarm)", 1.2, 0.8),
    ]

    for name, babble, clatter in scenarios:
        duration = 15.0
        noise = gen.mix_dynamic_scene(duration, babble, clatter)
        mixed = gen.add_alarm(noise.copy())

        # Save WAV
        wav_path = os.path.join(temp_dir, "test.wav")
        # Normalize
        m = np.max(np.abs(mixed))
        if m > 0:
            mixed = mixed / m * 0.95
        wavfile.write(wav_path, 44100, (mixed * 32767).astype(np.int16))

        # Run
        display = Display(verbose=False)
        runner = TestRunner(profile_path=Path(profile_path), verbose=False, display=display)

        runner.run_file(Path(wav_path))

        detections = len(runner.results.detections)
        status = "‚úÖ PASS" if detections > 0 else "‚ùå FAIL"

        print(
            f"Scenario: {name:25} | Babble: {babble:.1f} | Clatter: {clatter:.1f} | {status} ({detections} hits)"
        )

    import shutil

    shutil.rmtree(temp_dir)


if __name__ == "__main__":
    try:
        run_benchmark()
    except Exception:
        import traceback

        traceback.print_exc()
